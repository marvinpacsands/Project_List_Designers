<script>
/* ================= GLOBALS & STATE ================= */
let BOOT = null;
let MINE_ROWS = [], PM_ROWS = [], OPS_ROWS = [];
let PEOPLE_LIST = [];
let ACTIVE_TAB = '';
let PRIORITY_OPTIONS = [];
let PHASE_COLORS = {};
window.GLOBAL_META = window.GLOBAL_META || {}; // Store extra server data globally

// Expose to window for  external access (e.g. notifications.js)
// Use getters so they reflect updates to the local let variables
Object.defineProperty(window, 'MINE_ROWS', { get: () => MINE_ROWS });
Object.defineProperty(window, 'PM_ROWS', { get: () => PM_ROWS });
Object.defineProperty(window, 'OPS_ROWS', { get: () => OPS_ROWS });
Object.defineProperty(window, 'ACTIVE_TAB', { get: () => ACTIVE_TAB });

// Also hook into the setters if possible, or just rely on reference updates since arrays are references.
// But ACTIVE_TAB is a primitive string, so we need to update window.ACTIVE_TAB whenever ACTIVE_TAB changes.
// To avoid refactoring the whole app, we will just ensure notifications.js checks both.

const saveTimers = {};
const inflight = {};

/* ================= HELPERS ================= */
function normalize(s) { return String(s || '').toLowerCase().trim(); }
function rowKey(p, n) { return String(p || '') + '|' + String(n || ''); }
// --- Auto refresh guards (NEW) ---
let __autoRefreshTimer = null;
let __lastAutoRefreshMs = 0;

function isUiBusyForRefresh_() {
  const ae = document.activeElement;
  if (ae && ['INPUT', 'TEXTAREA', 'SELECT'].includes(ae.tagName)) return true;

  // Your custom multiselect uses .select-options dropdown
  const openDropdown = document.querySelector('.select-options:not(.hidden)');
  if (openDropdown) return true;

  // If any card is currently saving, don't refresh
  const savingDot = document.querySelector('.sync-dot.saving');
  if (savingDot) return true;

  return false;
}


/* ================= GAS BRIDGE (NEW) ================= */
// Promise wrapper for Apps Script server calls
function gasCall(fnName, arg) {
  return new Promise((resolve, reject) => {
    try {
      if (!(window.google && google.script && google.script.run)) {
        return reject(new Error('google.script.run not available'));
      }

      const runner = google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(err => {
          // Apps Script errors often come through as an object
          const msg = (err && err.message) ? err.message : String(err || 'Unknown error');
          reject(new Error(msg));
        });

      // Call server function dynamically
      if (arg === undefined) runner[fnName]();
      else runner[fnName](arg);

    } catch (e) {
      reject(e);
    }
  });
}

// Client wrappers (keep local fallback behavior if you ever run MY LOCAL FILES)
function apiBootstrapClient(email) {
  if (window.google && google.script && google.script.run) {
    return gasCall('apiBootstrap', email);
  }
  // Local fallback (Node/Express)
  return fetch('/api/bootstrap?email=' + encodeURIComponent(email)).then(r => r.json());
}

function apiUpdateClient(body) {
  if (window.google && google.script && google.script.run) {
    return gasCall('apiUpdate', body);
  }
  // Local fallback (Node/Express)
  return fetch('/api/update', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  }).then(r => r.json());
}


// Rank for sorting: 1 (Highest) -> 10 (Lowest). 
// Legacy/Status: Completed, Hold, Abandoned are special.
function getRank(p) {
  const s = normalize(p);
  // Status-based ranks (if p is a status)
  if (s === 'completed') return -10; // Bottom? Or Top? Usually completed is bottom/hidden.
  if (s === 'on hold') return -5;
  if (s === 'abandoned') return -20;

  // Numeric 1-10
  const n = parseInt(s, 10);
  if (!isNaN(n) && n >= 1 && n <= 10) {
    // 1 is Highest -> Return a large number to sort descending? 
    // Users sorting logic was: 1 is most priority.
    // If we sort descending by Rank:
    // 1 -> 100
    // 10 -> 91
    return 101 - n;
  }

  // Legacy string mapping (fallback)
  if (s === 'urgent') return 100; // Treat as 1
  if (s === 'high') return 98;    // Treat as 3
  if (s === 'medium') return 95;  // Treat as 6
  if (s === 'low') return 90;     // Treat as 10 (or below)

  return 0; // Unranked
}

// Color Class mapping based on Priority (1-10)
function getPrioClass(p) {
  const s = normalize(p);
  // Status check REMOVED per user request (only color if prioritized 1-10)
  /*
  if (s === 'on hold') return 'prio-hold';
  if (s === 'completed') return 'prio-done';
  if (s === 'abandoned') return 'prio-abandoned';
  */

  const n = parseInt(s, 10);
  if (!isNaN(n)) {
    if (n === 1) return 'prio-urgent'; // Red
    if (n === 2) return 'prio-medium'; // Blue
    if (n === 3) return 'prio-low';    // Yellow
    if (n >= 4) return 'prio-green';   // Green
  }

  return '';
}

// Determine effective priority for card styling
function getEffectivePrio(r, view) {
  const pmRank = getRank(r.pm?.priority);
  const myRank = getRank(r.my?.priority);

  if (view === 'mine') {
    if (normalize(r.my?.priority) === 'completed') return 'completed';
    if (normalize(r.my?.priority) === 'on hold') return 'on hold';
    if (normalize(r.my?.priority) === 'abandoned') return 'abandoned';
    // User requested to ignore PM priority for coloring in Mine view
    return r.my?.priority;
  }
  return r.pm?.priority;
}

/* ================= UI BUILDERS (SHARED) ================= */
function buildStatusBadge(status) {
  const div = document.createElement('div');
  div.className = 'status-badge';
  div.textContent = status || 'Unknown';
  if (PHASE_COLORS && PHASE_COLORS[normalize(status)]) {
    const hex = PHASE_COLORS[normalize(status)];
    div.style.backgroundColor = hex;
    div.style.color = '#fff';
    div.style.border = 'none';
    div.style.textShadow = '0 1px 2px rgba(0,0,0,0.3)';
  }
  return div;
}

function toggleCondensed(cardId) {
  const card = document.getElementById(cardId);
  if (card && card.classList.contains('condensed')) {
    card.classList.remove('condensed');
  } else if (card) {
    card.classList.add('condensed');
  }
}

function populateCategorizedSelect(sel, currentVal) {
  sel.innerHTML = '';

  const groups = {};

  PEOPLE_LIST.forEach(p => {
    const rolesRaw = p.role || 'Other';
    const roles = rolesRaw.split(',').map(s => s.trim()).filter(Boolean);

    roles.forEach(r => {
      const role = r.charAt(0).toUpperCase() + r.slice(1).toLowerCase();
      if (!groups[role]) groups[role] = [];
      if (!groups[role].some(x => x.name === p.name)) {
        groups[role].push(p);
      }
    });

    if (roles.length === 0) {
      if (!groups['Other']) groups['Other'] = [];
      groups['Other'].push(p);
    }
  });

  const nullOpt = document.createElement('option');
  nullOpt.value = ''; nullOpt.textContent = 'Unassigned';
  sel.appendChild(nullOpt);

  const roleOrder = ['PM', 'Operational', 'Designer'];
  const sortedKeys = Object.keys(groups).sort((a, b) => {
    const ia = roleOrder.indexOf(a.toUpperCase());
    const ib = roleOrder.indexOf(b.toUpperCase());
    if (ia !== -1 && ib !== -1) return ia - ib;
    if (ia !== -1) return -1;
    if (ib !== -1) return 1;
    return a.localeCompare(b);
  });

  sortedKeys.forEach(role => {
    const grp = document.createElement('optgroup');
    grp.label = role;
    groups[role].sort((a, b) => a.name.localeCompare(b.name)).forEach(p => {
      const o = document.createElement('option');
      o.value = p.name;
      o.textContent = p.name;
      if (String(p.name) === String(currentVal || '')) o.selected = true;
      grp.appendChild(o);
    });
    sel.appendChild(grp);
  });
}

function createMultiSelectDropdown(container, options, selected, onChange) {
  container.innerHTML = '';
  container.className = 'custom-multiselect';

  const trigger = document.createElement('div');
  trigger.className = 'select-trigger';
  trigger.style.background = 'var(--card-bg, #1e293b)';
  trigger.style.border = '1px solid var(--border-color, #334155)';
  trigger.style.borderRadius = '6px';
  trigger.style.height = '42px';
  trigger.style.fontSize = '13px';
  trigger.style.color = 'var(--text-color, #e2e8f0)';
  trigger.style.padding = '0 12px';
  trigger.style.display = 'flex';
  trigger.style.alignItems = 'center';
  trigger.style.justifyContent = 'space-between';

  const updateLabel = () => {
    const sel = options.filter(o => selected.includes(o.value));
    if (sel.length === 0) {
      trigger.textContent = 'Select PM(s)...';
      trigger.style.color = 'var(--text-muted, #94a3b8)';
    } else {
      // Ops Requirement: "do not say '2 selected' instead just print out the names"
      // We'll join them by comma for all cases, or maybe limit if too long?
      // User said "print out the names". We'll trust CSS text-overflow if needed.
      const names = sel.map(s => s.label).join(', ');
      trigger.textContent = names;
      trigger.style.color = 'var(--text-color, #e2e8f0)';

      // Add ellipsis if long via CSS
      trigger.style.whiteSpace = 'nowrap';
      trigger.style.overflow = 'hidden';
      trigger.style.textOverflow = 'ellipsis';
    }
    trigger.dataset.value = selected.join(',');
  };
  updateLabel();

  const dropdown = document.createElement('div');
  // ... (rest of function) ...

  function updateStats(rows) {
    let count = 0;
    const myName = normalize(BOOT.name);

    if (ACTIVE_TAB === 'mine') {
      rows.forEach(r => {
        if (r.team.some(t => normalize(t.name) === myName)) {
          count++;
        }
      });
    } else if (ACTIVE_TAB === 'pm') {
      rows.forEach(r => {
        const pms = (r.pmName || '').split(',').map(s => normalize(s));
        if (pms.includes(myName)) count++;
      });
    } else if (ACTIVE_TAB === 'ops') {
      // Ops: "include the total number of projects"
      count = rows.length;
    }

    const bar = document.getElementById('statsBar');
    if (bar) {
      const label = ACTIVE_TAB === 'ops' ? 'Total Projects' : 'My Projects';
      bar.innerHTML = `<div class="stat-pill">${label}: <b>${count}</b></div>`;
    }
  }
  dropdown.className = 'select-options';
  dropdown.style.display = 'none';
  dropdown.style.position = 'absolute';
  dropdown.style.zIndex = '9999';
  dropdown.style.width = '100%';
  dropdown.style.left = '0';
  dropdown.style.top = '100%';
  dropdown.style.boxSizing = 'border-box';
  dropdown.style.flexDirection = 'column';
  dropdown.style.backgroundColor = '#1e293b';
  dropdown.style.border = '1px solid #334155';
  dropdown.style.borderRadius = '6px';
  dropdown.style.boxShadow = '0 10px 15px -3px rgba(0, 0, 0, 0.5)';
  dropdown.style.maxHeight = '200px';
  dropdown.style.overflowY = 'auto';
  dropdown.style.marginTop = '4px';

  options.forEach(opt => {
    const lbl = document.createElement('label');
    lbl.style.display = 'flex';
    lbl.style.alignItems = 'center';
    lbl.style.width = '100%';
    lbl.style.padding = '8px 12px';
    lbl.style.cursor = 'pointer';
    lbl.style.borderBottom = '1px solid #334155';

    const chk = document.createElement('input');
    chk.type = 'checkbox';
    chk.value = opt.value;
    if (selected.includes(opt.value)) chk.checked = true;

    chk.addEventListener('change', () => {
      if (chk.checked) selected.push(opt.value);
      else selected = selected.filter(v => v !== opt.value);
      updateLabel();
      if (onChange) onChange(selected);
    });

    lbl.appendChild(chk);
    lbl.appendChild(document.createTextNode(' ' + opt.label));
    dropdown.appendChild(lbl);
  });

  trigger.addEventListener('click', (e) => {
    e.stopPropagation();
    const isHidden = dropdown.style.display === 'none';
    document.querySelectorAll('.select-options').forEach(d => d.style.display = 'none');
    dropdown.style.display = isHidden ? 'flex' : 'none';
  });

  document.addEventListener('click', (e) => {
    if (!container.contains(e.target)) dropdown.style.display = 'none';
  });

  container.appendChild(trigger);
  container.appendChild(dropdown);
}

function hydrateReactiveFilters(allRows, config) {
  const currentVals = {};
  config.forEach(c => {
    const el = document.getElementById(c.id);
    if (el) currentVals[c.id] = el.value;
  });

  config.forEach(target => {
    const validRows = allRows.filter(r => {
      return config.every(other => {
        if (other.id === target.id) return true;

        const filterVal = currentVals[other.id];
        if (!filterVal || filterVal === '__ALL__') return true;

        const val = other.transform ? other.transform(r[other.key]) : r[other.key];

        if (other.type === 'pm') {
          return (val || '').toLowerCase().includes(normalize(filterVal));
        }
        if (other.type === 'team') {
          if (Array.isArray(val)) return val.some(t => normalize(t.name) === normalize(filterVal));
          return normalize(val) === normalize(filterVal);
        }

        return normalize(val) === normalize(filterVal);
      });
    });

    const options = new Set();
    validRows.forEach(r => {
      let v = target.transform ? target.transform(r[target.key]) : r[target.key];
      if (target.type === 'pm' && v) {
        v.split(',').forEach(p => options.add(p.trim()));
      } else if (target.type === 'team' && Array.isArray(v)) {
        v.forEach(t => { if (t.name) options.add(t.name); });
      } else if (v) {
        options.add(v);
      }
    });

    const sorted = Array.from(options).sort((a, b) => {
      const na = parseInt(a, 10);
      const nb = parseInt(b, 10);
      if (!isNaN(na) && !isNaN(nb)) return na - nb;
      return String(a).localeCompare(String(b));
    });

    const sel = document.getElementById(target.id);
    if (!sel) return;

    sel.innerHTML = '';

    const def = document.createElement('option');
    def.value = '';
    def.textContent = target.defaultLabel || 'All';
    if (target.id === 'pmSelect') def.value = '__ALL__';
    sel.appendChild(def);

    if (target.id === 'pmSelect') {
      const me = document.createElement('option'); me.value = BOOT.name; me.textContent = 'My Projects';
      sel.appendChild(me);
      const all = document.createElement('option'); all.value = '__ALL__'; all.textContent = 'All Projects';
      sel.appendChild(all);
    }

    sorted.forEach(item => {
      if (target.id === 'pmSelect' && (item === '__ALL__' || normalize(item) === normalize(BOOT.name))) return;

      const opt = document.createElement('option');
      opt.value = item;
      opt.textContent = item;

      if (target.type === 'status') {
        const c = PHASE_COLORS[normalize(item)];
        if (c) { opt.style.backgroundColor = c; opt.style.color = '#fff'; }
      }

      if (String(item) === String(currentVals[target.id])) opt.selected = true;
      sel.appendChild(opt);
    });
  });
}

// ... helper ...

// Helper for "Neighbor Rank" (Unranked Sort)
function getNeighborBestRank(r) {
  const myName = normalize(BOOT?.name);
  const otherTeam = (r.team || []).filter(t => normalize(t.name) !== myName);

  let bestVal = 999;
  otherTeam.forEach(t => {
    const n = parseInt(t.priority, 10);
    if (!isNaN(n) && n >= 1 && n <= 10) {
      if (n < bestVal) bestVal = n;
    }
  });
  return bestVal; // 999 if no neighbor priority
}

function handleExclusion(container, changedInput) {
  // ... existing ... but redundant if I replace big chunks. I'll preserve hydrateReactiveFilters logic above
  // Exclude priority selectors (allow duplicates for shift logic)
  const selects = Array.from(container.querySelectorAll('select:not(.des-prio-sel)'));
  const values = selects.map(s => s.value).filter(Boolean);

  selects.forEach(sel => {
    const myVal = sel.value;
    Array.from(sel.options).forEach(opt => {
      if (!opt.value) return; // skip unassigned
      if (opt.value === myVal) {
        opt.disabled = false; return;
      }
      opt.disabled = values.includes(opt.value);
    });
  });
}

function adjustColor(hex, percent) {
  const num = parseInt(hex.replace('#', ''), 16);
  const amt = Math.round(2.55 * percent);
  const R = (num >> 16) + amt;
  const G = (num >> 8 & 0x00FF) + amt;
  const B = (num & 0x0000FF) + amt;
  return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
}

function updateStats(rows) {
  let count = 0;
  const myName = normalize(BOOT.name);

  if (ACTIVE_TAB === 'ops') {
    count = rows.length;
    // Ops Metrics
    const noPM = rows.filter(r => !r.pmName || normalize(r.pmName) === 'unassigned').length;
    const badSetup = rows.filter(r => r.missing && r.missing.length > 0).length;
    const completed = rows.filter(r => normalize(r.status) === 'completed').length;

    const bar = document.getElementById('statsBar');
    if (bar) {
      bar.innerHTML = `
                  <div class="stat-pill">Total: <b>${count}</b></div>
                  <div class="stat-pill" style="color:var(--text-muted); border-color:transparent;">Active: <b>${count - completed}</b></div>
                  ${noPM > 0 ? `<div class="stat-pill" style="color:#f59e0b; border-color:#f59e0b;">No PM: <b>${noPM}</b></div>` : ''}
                  ${badSetup > 0 ? `<div class="stat-pill" style="color:#ef4444; border-color:#ef4444;">Setup Needed: <b>${badSetup}</b></div>` : ''}
              `;
    }
    return;
  }

  // Archive Statuses definition
  const ARCHIVE_STATUSES = [
    'abandoned,expired',
    'approved - construction phase',
    'completed - sent to client',
    'paused - stalled by 3rd party',
    'do not click - final submit for approval'
  ];

  if (ACTIVE_TAB === 'mine') {
    rows.forEach(r => {
      // 1. Must be assigned to me
      const assigned = r.team.some(t => normalize(t.name) === myName);
      // 2. Must NOT be archived
      const isArchived = ARCHIVE_STATUSES.includes(normalize(r.status));

      if (assigned && !isArchived) count++;
    });
  } else if (ACTIVE_TAB === 'pm') {
    rows.forEach(r => {
      const pms = (r.pmName || '').split(',').map(s => normalize(s));
      const assigned = pms.includes(myName);
      const isArchived = ARCHIVE_STATUSES.includes(normalize(r.status));

      if (assigned && !isArchived) count++;
    });
  }

  const bar = document.getElementById('statsBar');
  if (bar) {
    const label = ACTIVE_TAB === 'pm' ? 'My Projects' : 'My Projects';
    bar.innerHTML = `<div class="stat-pill">${label}: <b>${count}</b></div>`;
  }
}

function saveRow(idx, view) {
  if (view === 'mine') {
    const card = document.getElementById(`card-${idx}`);
    const sel = card ? card.querySelector('select') : null;
    const taVal = card ? card.querySelector('textarea').value : '';
    const newPrio = sel ? sel.value : '';

    const r = MINE_ROWS.find(row => row.rowIndex === idx);
    if (r) {
      const oldPrio = r.my.priority;
      r.my.priority = newPrio;
      r.my.notes = taVal;

      if (typeof smartUpdateCard === 'function') {
        smartUpdateCard(idx, newPrio, oldPrio);
      }
    }

    const dot = document.getElementById(`dot-${idx}`);
    const msg = document.getElementById(`msg-${idx}`);
    if (dot) { dot.className = 'sync-dot saving'; }
    if (msg) { msg.textContent = 'Saving...'; }

    apiUpdateClient({
      email: window.currentUser.email,
      mode: 'mine',
      payload: { rowIndex: idx, priority: newPrio, notes: taVal }
    }).then(res => {
      if (dot) { dot.className = 'sync-dot saved'; setTimeout(() => dot.className = 'sync-dot', 2000); }
      if (msg) { msg.textContent = 'Upd ' + (res && res.savedAtDisplay ? res.savedAtDisplay : ''); }
    }).catch(err => {
      console.error(err);
      if (dot) { dot.className = 'sync-dot'; dot.style.background = 'red'; }
      if (msg) { msg.textContent = 'Error'; }
    });
  }
}


function debounceSave(idx, view) {
  clearTimeout(saveTimers[idx]);
  saveTimers[idx] = setTimeout(() => saveRow(idx, view), 1000);
}

function init() {
  const style = document.createElement('style');
  style.textContent = `
            .custom-multiselect { position: relative; width: 100%; font-family: 'Inter', sans-serif; }
            .select-trigger { background: #ffffff; padding: 10px 12px; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer; color: #0f172a; font-size: 13px; display: flex; align-items: center; justify-content: space-between; min-height: 42px; width: 100%; }
            .select-trigger:hover { border-color: #cbd5e1; }
            .select-trigger:after { content: '▼'; font-size: 10px; color: #94a3b8; }
            .select-options { position: absolute; top: 100%; left: 0; right: 0; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 6px; z-index: 100; max-height: 200px; overflow-y: auto; margin-top: 4px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }
            .select-options.hidden { display: none; }
            .select-options label { display: flex; align-items: center; padding: 8px 12px; cursor: pointer; color: #334155; font-size: 13px; border-bottom: 1px solid #f1f5f9; }
            .select-options label:last-child { border-bottom: none; }
            .select-options label:hover { background: #f8fafc; color: #0f172a; }
            .select-options input { margin-right: 10px; accent-color: #8b5cf6; }
            
            /* Injected Priority Green */
            .card.prio-green { background-color: #f0fdf4; border-left-color: #22c55e; }
        `;
  document.head.appendChild(style);

  const urlParams = new URLSearchParams(window.location.search);
  const emailParam = urlParams.get('email');
  const email = (window.currentUser ? window.currentUser.email : '') || emailParam || '';

  apiBootstrapClient(email)
    .then(b => {
      BOOT = b;
      initAdminViewAs_();
      PRIORITY_OPTIONS = b.priorityOptions || [];
      PHASE_COLORS = b.phaseColors || {};
      if (window.Notif) {
        Notif.init(b);
        document.addEventListener('click', () => Notif.requestPermission(), { once: true });
      }
      document.getElementById('whoami').textContent = `${b.name} (${(b.roles || []).join(', ')})`;
      if (b.logoUrl && b.logoUrl !== 'undefined') document.getElementById('logoImg').src = b.logoUrl;

      const roles = (b.roles || []).map(r => r.toUpperCase());
      const hasPM = roles.includes('PM');
      const hasOps = roles.includes('OPERATIONAL');

      const tMine = document.getElementById('tabMine');
      const tPM = document.getElementById('tabPM');
      const tOps = document.getElementById('tabOps');

      tMine.style.display = 'none';
      tPM.style.display = 'none';
      tOps.style.display = 'none';

      let availableTabs = [];
      if (hasOps) { tOps.style.display = 'inline-block'; tOps.onclick = () => switchTab('ops'); availableTabs.push('ops'); }
      // FIX: PMs can now see Designer Tab too
      if (hasPM) {
        tPM.style.display = 'inline-block';
        tPM.onclick = () => switchTab('pm');
        availableTabs.push('pm');

        // Add Mine Tab for PMs too (to view themselves as Designer)
        if (!availableTabs.includes('mine')) {
          tMine.style.display = 'inline-block';
          tMine.onclick = () => switchTab('mine');
          availableTabs.push('mine');
        }
      }

      const isPurePM = roles.length === 1 && roles[0] === 'PM';
      const isPureOps = roles.length === 1 && roles[0] === 'OPERATIONAL';
      const isPurePMOps = roles.length === 2 && hasPM && hasOps;

      if (!availableTabs.includes('mine')) {
        if (!isPurePMOps && !isPureOps) {
          tMine.style.display = 'inline-block';
          tMine.onclick = () => switchTab('mine');
          availableTabs.push('mine');
        }
      }

      if (roles.includes('DESIGNER')) {
        if (!availableTabs.includes('mine')) {
          tMine.style.display = 'inline-block';
          tMine.onclick = () => switchTab('mine');
          availableTabs.push('mine');
        }
      }

      document.getElementById('tabs').style.display = 'flex';

      ['mineSort', 'mineStatus', 'minePMFilter'].forEach(id => { document.getElementById(id).addEventListener('change', render); });
      document.getElementById('q').addEventListener('input', () => { clearTimeout(inflight.search); inflight.search = setTimeout(render, 300); });
      document.getElementById('opsSearch').addEventListener('input', render);
      ['opsDesignerFilter', 'opsPriorityFilter', 'opsPMFilter', 'opsStatusFilter', 'includeUnassigned'].forEach(id => { const el = document.getElementById(id); if (el) el.addEventListener('change', render); });

      // PM Sort listener
      const pmSort = document.getElementById('pmSort');
      if (pmSort) pmSort.addEventListener('change', render);

      if (hasPM || hasOps) {
        ['pmSelect', 'pmSort', 'pmStatusFilter', 'pmDesignerFilter'].forEach(id => {
          const el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('change', () => {
            if (id === 'pmSelect') {
              const val = el.value;
              if (window.Notif && typeof Notif.reset === 'function') try { Notif.reset('pm'); } catch (e) { }
              loadPM(val);
            } else { render(); }
          });
        });
      }

      // Default Tab Logic
      if (availableTabs.includes('pm')) switchTab('pm');
      else if (availableTabs.includes('ops')) switchTab('ops');
      else if (availableTabs.includes('mine')) switchTab('mine');

      if (availableTabs.includes('ops')) loadOperational();
      if (availableTabs.includes('pm')) { loadPM(b.name); }

      // Ensure only one auto-refresh timer exists
      if (__autoRefreshTimer) clearInterval(__autoRefreshTimer);

      // 8s feels much less “jittery” while still “live”
      // (we’ll later make this event-driven with Firebase signals)
      __autoRefreshTimer = setInterval(autoRefresh, 8000);
    })
    .catch(err => {
      console.error(err);
      // Fallback for testing/offline
      if (!BOOT) {
        console.warn('Using Fallback Bootstrap');
        BOOT = {
          name: 'Fallback Designer',
          email: 'marvsppam0@gmail.com', // Fix crash
          roles: ['DESIGNER'],
          priorityOptions: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
          phaseColors: {},
          pmList: ['Mock PM']
        };
        PRIORITY_OPTIONS = BOOT.priorityOptions;
        document.getElementById('whoami').textContent = BOOT.name;
        document.getElementById('tabs').style.display = 'flex';
        document.getElementById('tabMine').style.display = 'inline-block';
        document.getElementById('tabMine').onclick = () => switchTab('mine');
        switchTab('mine');
        setInterval(() => autoRefresh(), 2000);
      }
    });
}


function switchTab(t) {
  ACTIVE_TAB = t;
  document.getElementById('tabMine').classList.toggle('active', t === 'mine');
  document.getElementById('tabPM').classList.toggle('active', t === 'pm');
  document.getElementById('tabOps').classList.toggle('active', t === 'ops');
  document.getElementById('mineFilters').style.display = t === 'mine' ? 'flex' : 'none';
  document.getElementById('pmFilters').style.display = t === 'pm' ? 'flex' : 'none';
  document.getElementById('opsFilters').style.display = t === 'ops' ? 'flex' : 'none';
  if (window.Notif) Notif.reset(t);

  // Update Badges immediately to reflect "Seen" status (conceptually)
  // or at least to hide the badge of the tab we just entered.
  if (window.Notif && typeof window.Notif.checkBadges === 'function') {
    window.Notif.checkBadges();
  }

  render();
}

function autoRefresh() {
  if (isUiBusyForRefresh_()) return;

  const now = Date.now();
  if (now - __lastAutoRefreshMs < 4000) return;
  __lastAutoRefreshMs = now;

  if (ACTIVE_TAB === 'mine') {
    loadMine();
    return;
  }

  if (ACTIVE_TAB === 'pm') {
    // ✅ preserve PM view (My Projects / Unassigned / etc.)
    const pmSel = document.getElementById('pmSelect');
    const pmVal = pmSel ? pmSel.value : undefined;
    loadPM(pmVal);
    return;
  }

  if (ACTIVE_TAB === 'ops') {
    loadOperational();
    return;
  }
}



function getActiveEdit() { return document.querySelector('textarea:focus, select:focus'); }


// --- IMPERSONATION DROPDOWN ---
// --- IMPERSONATION DROPDOWN ---
function renderImpersonator() {
  let container = document.getElementById('impersonator-container');
  if (!container) {
    const header = document.querySelector('.header');
    if (header) {
      container = document.createElement('div');
      container.id = 'impersonator-container';
      container.style.cssText = "display:flex; align-items:center; margin-left: auto; gap: 8px;";
      header.appendChild(container); // Append to header flex
    }
  }

  if (!container || !GLOBAL_META || !GLOBAL_META.people) return;

  if (!document.getElementById('impersonator-select')) {
    const label = document.createElement('span');
    label.innerText = "View As:";
    label.style.fontSize = '12px';
    label.style.color = '#ccc';

    const select = document.createElement('select');
    select.id = 'impersonator-select';
    select.style.cssText = "background:#334155; color:white; border:1px solid #475569; padding:4px 8px; border-radius:4px; font-size:13px;";

    const sorted = [...GLOBAL_META.people].sort((a, b) => a.role.localeCompare(b.role) || a.name.localeCompare(b.name));

    const selfOpt = document.createElement('option');
    selfOpt.value = window.location.pathname;
    selfOpt.text = 'Reset (Me)';
    if (!window.location.search.includes('email=')) selfOpt.selected = true;
    select.appendChild(selfOpt);

    sorted.forEach(u => {
      const opt = document.createElement('option');
      const url = u.role.toUpperCase().includes('PM') ? `/pm?email=${u.email}` : `/designer?email=${u.email}`;
      opt.value = url;
      opt.text = `${u.name} (${u.role})`;
      if (window.location.search.includes(u.email)) opt.selected = true;
      select.appendChild(opt);
    });

    select.onchange = (e) => {
      window.location.href = e.target.value;
    };

    container.appendChild(label);
    container.appendChild(select);
  }
}

function render() {
  const gMine = document.getElementById('mineGrid');
  const gPM = document.getElementById('pmGrid');
  const gOps = document.getElementById('opsGrid');

  // Render Impersonator Dropdown
  renderImpersonator();

  gMine.style.display = ACTIVE_TAB === 'mine' ? 'grid' : 'none';
  gPM.style.display = ACTIVE_TAB === 'pm' ? 'grid' : 'none';
  gOps.style.display = ACTIVE_TAB === 'ops' ? 'grid' : 'none';

  const grid = ACTIVE_TAB === 'mine' ? gMine : (ACTIVE_TAB === 'pm' ? gPM : gOps);
  grid.innerHTML = '';

  let rows = ACTIVE_TAB === 'mine' ? [...MINE_ROWS] : (ACTIVE_TAB === 'pm' ? [...PM_ROWS] : [...OPS_ROWS]);

  // Refactor: Archive based on specific statuses, not priority
  const ARCHIVE_STATUSES = [
    'abandoned,expired',
    'approved - construction phase',
    'completed - sent to client',
    'paused - stalled by 3rd party',
    'do not click - final submit for approval'
  ];

  // Designer View Hook
  if (ACTIVE_TAB === 'pm' && typeof IS_DESIGNER_MODE !== 'undefined' && IS_DESIGNER_MODE && typeof renderDesignerBoard === 'function') {
    // Apply Filters first?
    // User: "filters to adjust how many".
    // But maybe standard filters (Status/PM) apply too? "filter to pm to...".
    // Assume filtering logic below runs first?
    // No, I inserted hook at TOP of render before filtering.
    // To support filtering, I should move hook AFTER filtering.
    // I'll insert it AFTER filtering logic (around line 720).
  }
  const q = normalize(document.getElementById(ACTIVE_TAB === 'ops' ? 'opsSearch' : 'q').value);

  // --- Ops View Filtering ---
  if (ACTIVE_TAB === 'ops') {
    hydrateReactiveFilters(OPS_ROWS, [
      { id: 'opsStatusFilter', key: 'status', type: 'status', defaultLabel: 'All Statuses' },
      { id: 'opsPMFilter', key: 'pmName', type: 'pm', defaultLabel: 'All PMs', transform: (v) => v || 'Unassigned' },
      { id: 'opsDesignerFilter', key: 'team', type: 'team', defaultLabel: 'All Designers' },
      { id: 'opsPriorityFilter', key: 'pm', type: 'priority', defaultLabel: 'All Priorities', transform: (v) => v?.priority }
    ]);

    const stFilter = document.getElementById('opsStatusFilter').value;
    const pmFilter = document.getElementById('opsPMFilter').value;
    const desFilter = document.getElementById('opsDesignerFilter').value;
    const priFilter = document.getElementById('opsPriorityFilter').value;
    const incUn = document.getElementById('includeUnassigned').checked;

    if (stFilter) rows = rows.filter(r => r.status === stFilter);
    if (pmFilter) {
      if (pmFilter === 'Unassigned') rows = rows.filter(r => !r.pmName);
      else rows = rows.filter(r => (r.pmName || '').toLowerCase().includes(normalize(pmFilter)));
    }
    if (desFilter) rows = rows.filter(r => r.team.some(t => normalize(t.name) === normalize(desFilter)));
    if (priFilter) rows = rows.filter(r => r.pm?.priority === priFilter);
    if (!incUn) rows = rows.filter(r => !!r.pmName);
    if (q) rows = rows.filter(r => (JSON.stringify(r).toLowerCase().includes(q)));

    updateStats(rows);

    const regularRows = [];
    const archiveRows = [];
    rows.forEach(r => {
      const p = normalize(r.pm?.priority);
      const s = normalize(r.status);
      if (s === 'completed' || p === 'completed' || p === 'on hold' || p === 'abandoned') {
        archiveRows.push(r);
      } else {
        regularRows.push(r);
      }
    });

    const archCont = document.getElementById('archiveContainer');
    if (archCont) {
      archCont.innerHTML = '';
      if (archiveRows.length > 0 && typeof renderArchiveFolder === 'function') {
        const folder = renderArchiveFolder(archiveRows, 'ops');
        if (folder) archCont.appendChild(folder);
      }
    }

    regularRows.sort((a, b) => parseFloat(b.projectNumber) - parseFloat(a.projectNumber));
    regularRows.forEach(r => grid.appendChild(buildOperationalCard(r)));
    return;
  }

  // --- PM View Filtering ---
  if (ACTIVE_TAB === 'pm') {
    // -------------------------------------------------------------
    // FEATURE: Unassigned Projects Flashing Button (User Request)
    // -------------------------------------------------------------
    const controlsArea = document.querySelector('.controls-area') || document.getElementById('pmFilters');

    // Safety check for PM_ROWS
    if (PM_ROWS) {
      let btnUnassigned = document.getElementById('btn-unassigned-projects');

      // Use GLOBAL_META.totalUnassigned if available (Server Truth), else fallback to filtered list count
      const unassignedCount = (typeof GLOBAL_META !== 'undefined' && GLOBAL_META.totalUnassigned !== undefined)
        ? GLOBAL_META.totalUnassigned
        : (PM_ROWS.filter(p => !p.pmName || p.pmName === 'Unassigned').length);

      if (unassignedCount > 0) {
        if (!btnUnassigned) {
          btnUnassigned = document.createElement('button');
          btnUnassigned.id = 'btn-unassigned-projects';
          btnUnassigned.className = 'btn-unassigned-flash';

          // Try to insert next to Designer View button
          const btnDes = document.getElementById('btnDesignerMode');
          if (btnDes && btnDes.parentNode) {
            btnDes.parentNode.insertBefore(btnUnassigned, btnDes.nextSibling);
          } else if (controlsArea) {
            controlsArea.appendChild(btnUnassigned);
          }

          btnUnassigned.onclick = () => {
            // NEW LOGIC: Just switch Dropdown to 'Unassigned'
            // This avoids popup and uses the natural filter flow
            const pmSelect = document.getElementById('pmSelect');
            if (pmSelect) {
              pmSelect.value = 'Unassigned';
              // Trigger change to load data
              pmSelect.dispatchEvent(new Event('change'));
            }
          };
        }
        btnUnassigned.innerHTML = `<span style="font-size:16px;">⚠️</span> Unassigned projects (${unassignedCount})`;
        btnUnassigned.style.display = 'flex';
      } else {
        if (btnUnassigned) btnUnassigned.style.display = 'none';
      }
    }

    // Check if Unassigned Filter is Active
    const btnUn = document.getElementById('btn-unassigned-projects');
    const showingUnassigned = btnUn && btnUn.classList.contains('active-filter');

    if (showingUnassigned) {
      // STICKY LOGIC: Prefer Sticky Rows over Server Rows
      if (window.STICKY_UNASSIGNED && window.STICKY_UNASSIGNED.length > 0) {
        const stickyMap = new Map(window.STICKY_UNASSIGNED.map(s => [s.rowIndex, s]));
        // 1. Replace existing
        rows = rows.map(r => stickyMap.has(r.rowIndex) ? stickyMap.get(r.rowIndex) : r);

        // 2. Add missing
        const currentIds = new Set(rows.map(r => r.rowIndex));
        window.STICKY_UNASSIGNED.forEach(sticky => {
          if (!currentIds.has(sticky.rowIndex)) {
            rows.push(sticky);
            currentIds.add(sticky.rowIndex);
          }
        });
      }

      rows = rows.filter(p => (!p.pmName || p.pmName === 'Unassigned') || (window.STICKY_UNASSIGNED && window.STICKY_UNASSIGNED.some(s => s.rowIndex === p.rowIndex)));
      // Add Banner
      const banner = document.createElement('div');
      banner.style.cssText = "background:#ef4444; color:white; padding:12px; margin-bottom:16px; border-radius:8px; display:flex; justify-content:space-between; align-items:center; grid-column: 1 / -1;";
      banner.innerHTML = `
            <span style="font-weight:bold;">Showing ${rows.length} Unassigned Projects</span>
            <button onclick="document.getElementById('btn-unassigned-projects').click()" style="background:white; color:#ef4444; border:none; padding:6px 12px; border-radius:4px; font-weight:bold; cursor:pointer;">Exit View</button>
         `;
      // We append banner later or just prepend to grid? 
      // Grid clears innerHTML, so we can prepend.
      // But grid logic might be complex. Let's handle it in LOOP or pre-loop.
      // Actually, let's prepend to grid AFTER clearing.
      // Grid passed to render functions.
      // We'll attach it to a temporary variable and append it after grid.innerHTML = ''
      if (grid) {
        // We can't append yet, grid.innerHTML = '' happens at top.
        // We are in filtering block.
        // Let's modify 'rows' and append banner to grid NOW? 
        // No, standard loop runs later.
        // Let's store flag to append banner.
      }
      // Also clear other filters?
    } else {
      hydrateReactiveFilters(PM_ROWS, [
        { id: 'pmStatusFilter', key: 'status', type: 'status', defaultLabel: 'All Statuses' },
        { id: 'pmDesignerFilter', key: 'team', type: 'team', defaultLabel: 'All Designers' }
      ]);

      const stFilter = document.getElementById('pmStatusFilter').value;
      const desFilter = document.getElementById('pmDesignerFilter').value;
      const pmSel = document.getElementById('pmSelect').value;

      if (pmSel && pmSel !== '__ALL__') {
        if (pmSel === 'Unassigned') {
          // STICKY LOGIC: Prefer Sticky Rows over Server Rows
          if (window.STICKY_UNASSIGNED && window.STICKY_UNASSIGNED.length > 0) {
            const stickyMap = new Map(window.STICKY_UNASSIGNED.map(s => [s.rowIndex, s]));
            // 1. Replace existing
            rows = rows.map(r => stickyMap.has(r.rowIndex) ? stickyMap.get(r.rowIndex) : r);

            // 2. Add missing
            const currentIds = new Set(rows.map(r => r.rowIndex));
            window.STICKY_UNASSIGNED.forEach(sticky => {
              if (!currentIds.has(sticky.rowIndex)) {
                rows.push(sticky);
                currentIds.add(sticky.rowIndex);
              }
            });
          }

          rows = rows.filter(r => {
            // 0. Sticky Override
            if (window.STICKY_UNASSIGNED && window.STICKY_UNASSIGNED.some(s => s.rowIndex === r.rowIndex)) return true;

            // 1. Truly Unassigned
            if (!r.pmName || r.pmName === 'Unassigned') return true;

            // 2. Retention: Assigned but Incomplete (Team slots empty)
            const incomplete = r.team.some(t => !t.name || t.name === '');
            if (incomplete) return true;

            return false;
          });
        } else {
          rows = rows.filter(r => (r.pmName || '').toLowerCase().includes(normalize(pmSel)));
        }
      }
      if (stFilter) rows = rows.filter(r => r.status === stFilter);
      if (desFilter) rows = rows.filter(r => r.team.some(t => normalize(t.name) === normalize(desFilter)));
      if (q) rows = rows.filter(r => (JSON.stringify(r).toLowerCase().includes(q)));
    }
  }

  if (ACTIVE_TAB === 'mine' && q) rows = rows.filter(r => (JSON.stringify(r).toLowerCase().includes(q)));

  if (ACTIVE_TAB === 'mine') {
    const filterStat = document.getElementById('mineStatus').value;
    if (filterStat) rows = rows.filter(r => normalize(r.status) === normalize(filterStat));
    const filterPM = document.getElementById('minePMFilter').value;
    if (filterPM) rows = rows.filter(r => normalize(r.pmName) === normalize(filterPM));
  }

  // 3. Sort & Stats
  if (ACTIVE_TAB === 'mine') {
    const mode = document.getElementById('mineSort').value;
    if (mode === 'smart') {
      rows.sort((a, b) => {
        // 1. Status (Completed/Hold/Abandoned to Archive) - Handled by filter/grouping usually, but for raw list:
        const aEff = getEffectivePrio(a, 'mine');
        const bEff = getEffectivePrio(b, 'mine');
        const aSpecial = ['completed', 'on hold', 'abandoned'].includes(normalize(aEff));
        const bSpecial = ['completed', 'on hold', 'abandoned'].includes(normalize(bEff));

        // Special items usually filtered out to Archive, but if they are here:
        if (aSpecial !== bSpecial) return aSpecial ? 1 : -1; // Non-special top

        // 2. My Priority (1-10)
        // getRank Returns 101-n (High Value = High Priority). 
        // 1 -> 100. 
        // Unranked -> 0.
        const myRankA = getRank(a.my?.priority);
        const myRankB = getRank(b.my?.priority);

        // If both ranked, sort descending
        if (myRankA > 0 || myRankB > 0) {
          return myRankB - myRankA;
        }

        // 3. Both Unranked: Sort by Neighbor Priority (Min Value is Best)
        const neighA = getNeighborBestRank(a);
        const neighB = getNeighborBestRank(b);
        if (neighA !== neighB) {
          return neighA - neighB; // 1 (Best) ... 10 ... 999
        }

        // 4. Default: Project #
        const an = parseFloat(a.projectNumber) || 0;
        const bn = parseFloat(b.projectNumber) || 0;
        return an - bn;
      });
    } else if (mode === 'projectno') {
      rows.sort((a, b) => {
        const an = parseFloat(a.projectNumber) || 0;
        const bn = parseFloat(b.projectNumber) || 0;
        return an - bn;
      });
    } else if (mode === 'lastmod') {
      rows.sort((a, b) => (b.lastModified?.dateMs || 0) - (a.lastModified?.dateMs || 0));
    }

    updateStats(rows);
  } else if (ACTIVE_TAB === 'pm') {
    // PM Sorting
    const sortMode = document.getElementById('pmSort').value;

    rows.sort((a, b) => {
      // Helper: Get Sorted Priorities (Best to Worst)
      const getPrios = (r) => {
        const p = [];
        (r.team || []).forEach(t => {
          const val = parseInt(t.priority);
          if (!isNaN(val) && val >= 1 && val <= 10) p.push(val);
        });
        return p.sort((x, y) => x - y);
      };

      // Helper: Get Sequence Number (Tie-Breaker)
      const getSeq = (r) => {
        if (!r.projectNumber) return 999999;
        const parts = String(r.projectNumber).split('-');
        const seq = parseInt(parts[parts.length - 1]);
        return isNaN(seq) ? 999999 : seq;
      };

      if (sortMode === 'maxPrioAsc' || sortMode === 'maxPrioDesc') {
        const pA = getPrios(a);
        const pB = getPrios(b);
        const maxLen = Math.max(pA.length, pB.length);

        for (let i = 0; i < maxLen; i++) {
          // Missing priority = 999 (Worse than any valid priority)
          const valA = pA[i] !== undefined ? pA[i] : 999;
          const valB = pB[i] !== undefined ? pB[i] : 999;

          if (valA !== valB) {
            // Asc (High -> Low): Lower number is better (comes first).
            if (sortMode === 'maxPrioAsc') return valA - valB;
            // Desc (Low -> High / Unassigned First): Higher number comes first
            return valB - valA;
          }
        }

        // Tie-Breaker: Sequence Number
        const seqA = getSeq(a);
        const seqB = getSeq(b);

        // Asc: "Lower number the more priority" -> Lower Seq comes First.
        if (sortMode === 'maxPrioAsc') return seqA - seqB;
        // Desc: Higher Seq comes First.
        return seqB - seqA;
      } else if (sortMode === 'customSort') {
        // Custom Sort: Use saved order from server
        const customOrder = (window.GLOBAL_META && window.GLOBAL_META.customSortOrder) || [];

        // Convert to string for comparison (customOrder contains strings, rowIndex may be number or string)
        const indexA = customOrder.indexOf(String(a.rowIndex));
        const indexB = customOrder.indexOf(String(b.rowIndex));

        // If both in custom order, sort by their saved position
        if (indexA !== -1 && indexB !== -1) return indexA - indexB;

        // If only A is in custom order, A comes first
        if (indexA !== -1) return -1;

        // If only B is in custom order, B comes first
        if (indexB !== -1) return 1;

        // If neither in custom order, use project number
        return (parseFloat(b.projectNumber) || 0) - (parseFloat(a.projectNumber) || 0);
      }

      // Default / Tie-breaker (if not using sort mode): Project # Descending
      return (parseFloat(b.projectNumber) || 0) - (parseFloat(a.projectNumber) || 0);
    });
    updateStats(rows);
  }

  // 4. Render Layout
  if (ACTIVE_TAB === 'pm' && typeof IS_DESIGNER_MODE !== 'undefined' && IS_DESIGNER_MODE && typeof renderDesignerBoard === 'function') {
    renderDesignerBoard(grid, rows);
    return;
  }

  if (ACTIVE_TAB === 'mine') {
    const regularRows = [];
    const archiveRows = [];

    rows.forEach(r => {
      // Archive based on Status
      if (ARCHIVE_STATUSES.includes(normalize(r.status))) {
        archiveRows.push(r);
      } else {
        regularRows.push(r);
      }
    });

    const archCont = document.getElementById('archiveContainer');
    if (archCont) archCont.innerHTML = '';

    // START Trigger Update (Mine)
    if (typeof updateArchiveTrigger === 'function') {
      updateArchiveTrigger(archiveRows, 'mine');
    }
    regularRows.forEach(r => grid.appendChild(buildMineCard(r)));

  } else if (ACTIVE_TAB === 'pm') {
    const regularRows = [];
    const archiveRows = [];

    rows.forEach(r => {
      // PM Archive Logic
      if (ARCHIVE_STATUSES.includes(normalize(r.status))) {
        archiveRows.push(r);
      } else {
        regularRows.push(r);
      }
    });

    // START Trigger Update (PM)
    if (typeof updateArchiveTrigger === 'function') {
      updateArchiveTrigger(archiveRows, 'pm');
    }
    // const archiveFolder = renderArchiveFolder(archiveRows, 'pm'); // Removed
    // if (archiveFolder) grid.appendChild(archiveFolder); // Removed

    regularRows.forEach(r => {
      const card = buildPMCard(r);
      grid.appendChild(card);

      // Enable drag-drop only in custom sort mode
      const sortMode = document.getElementById('pmSort').value;
      if (sortMode === 'customSort') {
        card.draggable = true;
        card.style.cursor = 'grab';

        card.addEventListener('dragstart', (e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', r.rowIndex);
          card.style.opacity = '0.5';
        });

        card.addEventListener('dragend', () => {
          card.style.opacity = '1';
        });

        card.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          card.style.borderTop = '3px solid #3b82f6';
        });

        card.addEventListener('dragleave', () => {
          card.style.borderTop = '';
        });

        card.addEventListener('drop', (e) => {
          e.preventDefault();
          card.style.borderTop = '';

          const draggedRowIndex = e.dataTransfer.getData('text/plain');
          const targetRowIndex = r.rowIndex;

          if (draggedRowIndex === String(targetRowIndex)) return;

          // Reorder the cards
          const allCards = Array.from(grid.children);
          const orderedRowIndexes = allCards.map(c => c.id.replace('card-', ''));

          // Remove dragged item and insert before target
          const draggedIndex = orderedRowIndexes.indexOf(String(draggedRowIndex));
          const targetIndex = orderedRowIndexes.indexOf(String(targetRowIndex));

          if (draggedIndex !== -1) {
            orderedRowIndexes.splice(draggedIndex, 1);
            const newTargetIndex = draggedIndex < targetIndex ? targetIndex - 1 : targetIndex;
            orderedRowIndexes.splice(newTargetIndex, 0, String(draggedRowIndex));
          }

          // Save to server
          saveCustomOrder(orderedRowIndexes);

          // Re-render
          render();
        });
      } else {
        card.draggable = false;
        card.style.cursor = '';
      }
    });

  } else if (ACTIVE_TAB === 'ops') {
    updateStats(rows); // Reuse or custom? updateStats counts "My Projects".
  } else {
    rows.forEach(r => grid.appendChild(buildOperationalCard(r)));
    // Ops stats?
  }
}
function buildAdminViewAsBar_() {
  if (document.getElementById('admin-viewas-bar')) return;

  const bar = document.createElement('div');
  bar.id = 'admin-viewas-bar';
  bar.style.cssText = `
    display:flex;
    gap:10px;
    align-items:center;
    padding:8px 12px;
    margin:10px 0;
    border:1px solid #e2e8f0;
    background:#f8fafc;
    border-radius:8px;
    font-family: Inter, sans-serif;
    font-size:12px;
  `;

  bar.innerHTML = `
    <div style="font-weight:700; color:#0f172a;">ADMIN</div>
    <div style="color:#475569;">View as:</div>
    <select id="adminViewAsSelect" style="padding:6px 8px; border:1px solid #cbd5e1; border-radius:6px; min-width:240px;"></select>
    <button id="adminViewAsReset" style="padding:6px 10px; border:1px solid #cbd5e1; border-radius:6px; background:white; cursor:pointer; font-weight:600;">
      Reset (Me)
    </button>
    <div id="adminViewAsHint" style="margin-left:auto; color:#64748b;"></div>
  `;

  // Insert above tabs if possible; otherwise top of body
  const tabs = document.getElementById('tabs');
  if (tabs && tabs.parentNode) tabs.parentNode.insertBefore(bar, tabs);
  else document.body.insertBefore(bar, document.body.firstChild);
}

function initAdminViewAs_() {
  const cu = window.currentUser || {};
  if (!cu.isAdmin) return;

  buildAdminViewAsBar_();

  const actor = (cu.actorEmail || cu.email || '').toLowerCase();
  const target = (cu.email || '').toLowerCase();

  const sel = document.getElementById('adminViewAsSelect');
  const btn = document.getElementById('adminViewAsReset');
  const hint = document.getElementById('adminViewAsHint');

  function goExec_(pickedEmailOrEmpty) {
    const picked = String(pickedEmailOrEmpty || '').trim().toLowerCase();

    const base = (window.WEBAPP_URL || '').trim(); // real /exec URL from server
    if (!base) {
      // fallback (should rarely happen)
      const u = new URL(window.location.href);
      u.searchParams.delete('impersonate');
      if (picked && picked !== actor) u.searchParams.set('impersonate', picked);
      window.location.href = u.toString();
      return;
    }

    const u = new URL(base);
    u.searchParams.delete('impersonate');
    if (picked && picked !== actor) u.searchParams.set('impersonate', picked);

    // IMPORTANT: force top-level navigation (prevents white sandbox panel)
    const nextUrl = u.toString();
    try {
      window.open(nextUrl, '_top');   // most reliable in GAS iframe
    } catch (e) {
      try { window.top.location.href = nextUrl; }
      catch (e2) { window.location.href = nextUrl; }
    }
  }

  if (hint) {
    hint.textContent = (target !== actor)
      ? `Viewing as ${target} (you: ${actor})`
      : `You: ${actor}`;
  }

  gasCall('apiAdminListUsers')
    .then(users => {
      sel.innerHTML = '';

      const meOpt = document.createElement('option');
      meOpt.value = actor;
      meOpt.textContent = `Me (${actor})`;
      sel.appendChild(meOpt);

      (users || []).forEach(u => {
        const opt = document.createElement('option');
        opt.value = String(u.email || '').toLowerCase();
        opt.textContent = `${u.name} — ${u.email}${u.role ? ` (${u.role})` : ''}`;
        sel.appendChild(opt);
      });

      sel.value = target || actor;
    })
    .catch(err => {
      console.error('apiAdminListUsers failed:', err);
      sel.innerHTML = `<option value="${actor}">Me (${actor})</option>`;
      sel.value = target || actor;
    });

  sel.onchange = () => goExec_(sel.value);
  btn.onclick = () => goExec_('');
}


document.addEventListener('DOMContentLoaded', init);
/* End Refactored core.js */
</script>